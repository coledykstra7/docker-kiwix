# Use relative paths for logs and PID 
error_log /dev/stderr debug;
worker_processes auto;
pid /tmp/nginx.pid;

events {
    worker_connections 768;
}

http {

    ##
    # Basic Settings
    ##

    sendfile on;
    tcp_nopush on;
    types_hash_max_size 2048;

    include mime.types;
    default_type application/octet-stream;

    ##
    # SSL Settings
    ##

    ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;

    ##
    # Logging Settings
    ##

    access_log /dev/stdout;

    ##
    # Gzip Settings
    ##

    gzip on;
    gzip_proxied any;

    server {
        listen 8080;
        server_name _;
        root html;

        error_page 403 = /catch_block.html;
        location = /catch_block.html {
            # The root is already defined in your server block, so this is optional
            # but can be explicit: root /usr/local/openresty/nginx/html;
            internal;
        }

        location = /catch/external {
            try_files /catch_external.html =404;
        }

        location = /search {
            try_files /catch_search.html =404;
        }

        location = /content/explainxkcd_en_all_maxi_2021-03/ {
            rewrite ^ /random?content=explainxkcd_en_all_maxi_2021-03 last;
        }
        location = /content/explainxkcd_en_all_maxi_2021-03 {
            rewrite ^ /random?content=explainxkcd_en_all_maxi_2021-03 last;
        }

        location ~* /_zim_static/(wombat|wombatSetup)\.js$ {
            return 404;
        }

        location / {
            # OpenResty Lua blocking logic
            access_by_lua_block {
                local ip = ngx.var.remote_addr
                local uri = ngx.var.request_uri

                local is_blocked = false

                -- Global Rules (for ALL IPs)
                -- Using ngx.re.find for PCRE regex matching as it's more flexible
                -- and closer to Nginx's native regex. 'i' for case-insensitive.
                if ngx.re.find(uri, "/content/gutenberg.*Kama.*Sutra", "i") or
                ngx.re.find(uri, "/content.*wikipedia.*/lion", "i") or
                ngx.re.find(uri, "/content.*wikipedia.*/tiger", "i") or
                ngx.re.find(uri, "/content.*wikipedia.*/bear", "i")
                then
                    is_blocked = true
                end

                if is_blocked then
                    ngx.log(ngx.WARN, "[LUA] Blocked request from IP: ", ip, " for URI: ", uri)
                    return ngx.exit(ngx.HTTP_FORBIDDEN)
                end
            }
            # Disable compression from upstream server to allow Nginx/Lua to process raw content
            proxy_set_header Accept-Encoding ""; 
            proxy_buffering on; # Important for body_filter_by_lua_block to work correctly
            proxy_request_buffering on;

            proxy_pass http://kiwix:8000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            add_header X-Nginx-Processed "true";

            # This block prepares the response for modification.
            # We must clear Content-Length because the body size will change.
            header_filter_by_lua_block {
                local content_type = ngx.header["Content-Type"]
                if content_type and content_type:match("text/html") then
                    -- Clear Content-Length because body size will change after modification
                    ngx.header["Content-Length"] = nil
                    ngx.header["X-Lua-Processed"] = "true"
                    -- ngx.log(ngx.DEBUG, "[LUA] Header filter active for HTML: Content-Type=", content_type)
                    -- Set a context variable to indicate body filter should process this response
                    ngx.ctx.process_html = true
                else
                    -- Don't process non-HTML content
                    ngx.ctx.process_html = false
                    --ngx.log(ngx.DEBUG, "[LUA] Header filter skipping non-HTML: Content-Type=", tostring(content_type))
                end
            }

            # This block performs the actual substitution on the response body chunks.
            body_filter_by_lua_block {
                -- Only process if we marked this as HTML in header filter
                if not ngx.ctx.process_html then
                    return
                end

                local function replace_pattern(content, pattern, replacement, description)
                    local count
                    content, count = ngx.re.gsub(content, pattern, replacement, "is")
                    if count and count > 0 then
                        ngx.log(ngx.DEBUG, '[LUA] Replaced ' .. count .. ' occurrences: ' .. (description or pattern))
                    end
                    return content
                end

                local chunk = ngx.arg[1]
                local eof = ngx.arg[2] -- end of file flag

                if chunk then
                    -- Initialize buffer if this is the first chunk
                    if not ngx.ctx.buffer then
                        ngx.ctx.buffer = {}
                    end
                    
                    -- Collect all chunks
                    table.insert(ngx.ctx.buffer, chunk)
                    
                    -- Don't output anything yet
                    ngx.arg[1] = nil
                end

                -- Process the complete response when we reach EOF
                if eof then
                    ngx.log(ngx.DEBUG, '[LUA] eof: Request - Method: ', ngx.var.request_method, ' URL: ', ngx.var.request_uri, ' Host: ', ngx.var.host)
                    local full_content = ""
                    if ngx.ctx.buffer then
                        full_content = table.concat(ngx.ctx.buffer)
                    end

                    if ngx.var.request_uri == "/content/wikipedia_en_100_2025-07/List_of_presidents_of_the_United_States" then
                        full_content = replace_pattern(full_content, "Trump", "Dump", "Trump -> Dump")
                    else
                        full_content = replace_pattern(full_content, [=[<a href="https://kiwix\.org">Kiwix</a>]=], "Kiwix", "kiwix.org link")
                    end
                    
                    -- Strip external links - multiple patterns for better coverage
                    local external_link_patterns = {
                        -- Basic HTTP/HTTPS links
                        '<a[^>]*?href=["\']https?://[^"\']*?["\'][^>]*?>(.*?)</a>',
                        
                        -- Links with additional protocols (ftp, mailto, etc.)
                        '<a[^>]*?href=["\'](?:ftp|mailto|tel)://[^"\']*?["\'][^>]*?>(.*?)</a>',
                        
                        -- Links that might have spaces or other attributes
                        '<a\\s+[^>]*?href\\s*=\\s*["\']https?://[^"\']*?["\'][^>]*?>(.*?)</a>',
                        
                        -- Handle single quotes vs double quotes
                        "<a[^>]*?href='https?://[^']*?'[^>]*?>(.*?)</a>",
                        
                        -- Catch any remaining external links (starting with http/https)
                        '<a[^>]*?href=[^>]*?(?:https?://)[^>]*?>(.*?)</a>'
                    }
                    
                    -- Apply each pattern
                    for i, pattern in ipairs(external_link_patterns) do
                        full_content = replace_pattern(full_content, pattern, "$1", "External links (pattern " .. i .. ")")
                    end

                    -- Output the modified content
                    ngx.arg[1] = full_content
                    
                    ngx.log(ngx.DEBUG, "[LUA] Body filter processed HTML content, size: ", string.len(full_content))
                end
            }
        }
    }
}
